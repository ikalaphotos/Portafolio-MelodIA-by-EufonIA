# -*- coding: utf-8 -*-
"""UntMelodIA_Fase1_Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lj5IJ8mkwhxfBPtBJ1LKMYwdV7puudaw
"""

import pandas as pd
import numpy as np

print("Iniciando Fase 1: Generaci贸n de Dataset Simulado (Mocking)...")
print("API de Spotify bloqueada (403). Pivotando a generaci贸n de datos locales.")

# --- 1. Definici贸n de la Hip贸tesis (M茅todo EufonIA) ---
# Definimos las "firmas" s贸nicas que esperamos de cada fase.
# (Media, Desviaci贸n Est谩ndar) para la generaci贸n aleatoria.
SPEC_ALFA = {'bpm_tempo': (80, 10), 'energia': (0.4, 0.1), 'valencia_positiva': (0.6, 0.1)}
SPEC_THETA = {'bpm_tempo': (60, 5), 'energia': (0.2, 0.05), 'valencia_positiva': (0.5, 0.1)}
SPEC_BETA = {'bpm_tempo': (125, 10), 'energia': (0.7, 0.1), 'valencia_positiva': (0.7, 0.1)}

N_SAMPLES_PER_CATEGORY = 200 # Generamos 200 canciones por categor铆a

def generate_songs_for_phase(categoria, spec):
    """
    Genera un DataFrame de canciones simuladas para una fase espec铆fica.
    """
    print(f"-> Generando {N_SAMPLES_PER_CATEGORY} muestras para la [Fase: {categoria}]...")

    # Usamos Numpy para crear distribuciones normales basadas en nuestras especificaciones
    bpm = np.random.normal(loc=spec['bpm_tempo'][0], scale=spec['bpm_tempo'][1], size=N_SAMPLES_PER_CATEGORY)
    energia = np.random.normal(loc=spec['energia'][0], scale=spec['energia'][1], size=N_SAMPLES_PER_CATEGORY)
    valencia = np.random.normal(loc=spec['valencia_positiva'][0], scale=spec['valencia_positiva'][1], size=N_SAMPLES_PER_CATEGORY)

    # Simulamos otras m茅tricas que KNIME analizar谩
    acustica = np.random.uniform(low=0.1, high=0.9, size=N_SAMPLES_PER_CATEGORY)
    instrumental = np.random.uniform(low=0.5, high=1.0, size=N_SAMPLES_PER_CATEGORY)

    df_phase = pd.DataFrame({
        'categoria_eufonia': categoria,
        'bpm_tempo': bpm,
        'energia': energia,
        'valencia_positiva': valencia,
        'acustica': acustica,
        'instrumental': instrumental
    })

    # Nos aseguramos de que los valores est茅n en el rango correcto (0.0 a 1.0)
    df_phase['energia'] = np.clip(df_phase['energia'], 0.0, 1.0)
    df_phase['valencia_positiva'] = np.clip(df_phase['valencia_positiva'], 0.0, 1.0)

    return df_phase

# --- 2. Funci贸n Principal ---
def create_mock_dataset():

    # Generamos los datos para cada fase
    df_alfa = generate_songs_for_phase("Fase_Alfa_Induccion", SPEC_ALFA)
    df_theta = generate_songs_for_phase("Fase_Theta_Carga", SPEC_THETA)
    df_beta = generate_songs_for_phase("Fase_Beta_Activacion", SPEC_BETA)

    # Combinamos los 3 DataFrames en uno solo
    df_final = pd.concat([df_alfa, df_theta, df_beta], ignore_index=True)

    # Guardamos el CSV en el entorno de Colab
    output_filename = "melodia_dataset.csv"
    df_final.to_csv(output_filename, index=False)

    print("\n" + "="*50)
    print(f"隆XITO! Dataset simulado creado: {output_filename}")
    print(f"Total de canciones generadas: {len(df_final)}")
    print("Vista previa de los datos simulados:")
    print(df_final.head())
    print("="*50)
    print(f"Puedes descargar el archivo '{output_filename}' desde el panel izquierdo (icono de carpeta ).")
    print("隆Ya estamos listos para la Fase 2 en KNIME!")

# --- 3. Ejecutar la Funci贸n ---
create_mock_dataset()
